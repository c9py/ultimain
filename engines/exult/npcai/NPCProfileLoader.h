/**
 * NPCProfileLoader.h - Load NPC profiles from JSON for AI integration
 *
 * Loads NPC profiles generated by osm2ultima and registers them with
 * the ExultNPCBridge for cognitive AI behavior.
 *
 * Part of the Ultima Integration Project
 */

#ifndef NPC_PROFILE_LOADER_H
#define NPC_PROFILE_LOADER_H

#include "ExultNPCBridge.h"
#include <string>
#include <vector>
#include <map>
#include <fstream>
#include <sstream>

namespace Ultima {
namespace Exult {

/**
 * NPCProfileLoader - Loads NPC profiles from JSON files
 */
class NPCProfileLoader {
public:
    /**
     * Load NPC profiles from a JSON file generated by osm2ultima
     *
     * @param filepath Path to npc_profiles.json
     * @return Vector of loaded profiles
     */
    static std::vector<NPCProfile> loadFromFile(const std::string& filepath);

    /**
     * Load NPC profiles from a JSON string
     *
     * @param jsonData JSON string containing NPC profiles
     * @return Vector of loaded profiles
     */
    static std::vector<NPCProfile> loadFromString(const std::string& jsonData);

    /**
     * Register all loaded profiles with the ExultNPCBridge
     *
     * @param profiles Vector of profiles to register
     * @param actorLookup Function to find Actor* by shape and location
     * @return Number of successfully registered NPCs
     */
    template<typename ActorLookupFunc>
    static int registerProfiles(
        const std::vector<NPCProfile>& profiles,
        ActorLookupFunc actorLookup
    ) {
        int registered = 0;
        ExultNPCBridge& bridge = ExultNPCBridge::getInstance();

        for (const auto& profile : profiles) {
            // Look up the Actor in the game world
            Actor* actor = actorLookup(profile.id, profile.name);

            if (actor && bridge.registerNPC(actor, profile)) {
                registered++;
            }
        }

        return registered;
    }

    /**
     * Generate a default profile for an actor not in the loaded profiles
     *
     * @param actorShape The shape number of the actor
     * @param location Tile coordinates (x, y)
     * @return Generated NPCProfile
     */
    static NPCProfile generateDefaultProfile(int actorShape, int tileX, int tileY);

private:
    // Simple JSON parsing helpers (minimal implementation)
    static std::string extractString(const std::string& json, const std::string& key);
    static float extractFloat(const std::string& json, const std::string& key, float defaultVal = 0.5f);
    static std::vector<std::string> extractStringArray(const std::string& json, const std::string& key);
    static std::map<std::string, float> extractFloatMap(const std::string& json, const std::string& key);
};

/**
 * NPCAIInitializer - Initialize the NPC AI system for Exult
 */
class NPCAIInitializer {
public:
    /**
     * Initialize the NPC AI system
     *
     * @param dataDirectory Path to NPC AI data files
     * @param profilesPath Optional path to npc_profiles.json
     * @return true if initialization succeeded
     */
    static bool initialize(
        const std::string& dataDirectory = "data/npcai",
        const std::string& profilesPath = ""
    );

    /**
     * Shutdown the NPC AI system
     */
    static void shutdown();

    /**
     * Check if initialized
     */
    static bool isInitialized();

    /**
     * Update all cognitive NPCs (call each game tick)
     *
     * @param deltaTime Time since last update in seconds
     */
    static void update(double deltaTime);

    /**
     * Get statistics about the NPC AI system
     */
    struct Stats {
        int totalNPCs;
        int activeConversations;
        int memoryEvents;
        double averageResponseTime;
    };
    static Stats getStats();

private:
    static bool initialized_;
    static std::string dataDirectory_;
};

// =============================================================================
// Implementation (header-only for simplicity)
// =============================================================================

inline std::vector<NPCProfile> NPCProfileLoader::loadFromFile(const std::string& filepath) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        return {};
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    return loadFromString(buffer.str());
}

inline std::vector<NPCProfile> NPCProfileLoader::loadFromString(const std::string& jsonData) {
    std::vector<NPCProfile> profiles;

    // Find the "npcs" array
    size_t npcsStart = jsonData.find("\"npcs\"");
    if (npcsStart == std::string::npos) return profiles;

    size_t arrayStart = jsonData.find('[', npcsStart);
    if (arrayStart == std::string::npos) return profiles;

    // Parse each NPC object
    size_t pos = arrayStart + 1;
    while (pos < jsonData.size()) {
        size_t objStart = jsonData.find('{', pos);
        if (objStart == std::string::npos) break;

        // Find matching closing brace
        int braceCount = 1;
        size_t objEnd = objStart + 1;
        while (objEnd < jsonData.size() && braceCount > 0) {
            if (jsonData[objEnd] == '{') braceCount++;
            else if (jsonData[objEnd] == '}') braceCount--;
            objEnd++;
        }

        if (braceCount != 0) break;

        std::string npcJson = jsonData.substr(objStart, objEnd - objStart);

        NPCProfile profile;
        profile.id = extractString(npcJson, "id");
        profile.name = extractString(npcJson, "name");
        profile.profession = extractString(npcJson, "profession");

        // Extract personality traits
        size_t persStart = npcJson.find("\"personality\"");
        if (persStart != std::string::npos) {
            size_t persEnd = npcJson.find('}', persStart);
            std::string persJson = npcJson.substr(persStart, persEnd - persStart + 1);
            profile.openness = extractFloat(persJson, "openness", 0.5f);
            profile.conscientiousness = extractFloat(persJson, "conscientiousness", 0.5f);
            profile.extraversion = extractFloat(persJson, "extraversion", 0.5f);
            profile.agreeableness = extractFloat(persJson, "agreeableness", 0.5f);
            profile.neuroticism = extractFloat(persJson, "neuroticism", 0.5f);
        }

        profile.knowledgeDomains = extractStringArray(npcJson, "knowledge_domains");
        profile.relationships = extractFloatMap(npcJson, "relationships");

        if (!profile.id.empty()) {
            profiles.push_back(profile);
        }

        pos = objEnd;
    }

    return profiles;
}

inline NPCProfile NPCProfileLoader::generateDefaultProfile(int actorShape, int tileX, int tileY) {
    NPCProfile profile;

    // Generate ID from shape and location
    std::stringstream ss;
    ss << "npc_auto_" << actorShape << "_" << tileX << "_" << tileY;
    profile.id = ss.str();

    // Determine profession from shape
    // These are common Ultima VII NPC shapes
    switch (actorShape) {
        case 265: case 319: case 452:
            profile.profession = "townsman";
            profile.name = "Peasant";
            break;
        case 459:
            profile.profession = "townswoman";
            profile.name = "Woman";
            break;
        case 394:
            profile.profession = "guard";
            profile.name = "Guard";
            profile.conscientiousness = 0.8f;
            profile.extraversion = 0.4f;
            break;
        case 454: case 455:
            profile.profession = "shopkeeper";
            profile.name = "Merchant";
            profile.extraversion = 0.7f;
            break;
        case 304:
            profile.profession = "blacksmith";
            profile.name = "Smith";
            profile.conscientiousness = 0.8f;
            break;
        case 318: case 448:
            profile.profession = "sage";
            profile.name = "Scholar";
            profile.openness = 0.8f;
            break;
        default:
            profile.profession = "townsman";
            profile.name = "Stranger";
            break;
    }

    return profile;
}

inline std::string NPCProfileLoader::extractString(const std::string& json, const std::string& key) {
    std::string searchKey = "\"" + key + "\"";
    size_t keyPos = json.find(searchKey);
    if (keyPos == std::string::npos) return "";

    size_t colonPos = json.find(':', keyPos);
    if (colonPos == std::string::npos) return "";

    size_t startQuote = json.find('"', colonPos);
    if (startQuote == std::string::npos) return "";

    size_t endQuote = json.find('"', startQuote + 1);
    if (endQuote == std::string::npos) return "";

    return json.substr(startQuote + 1, endQuote - startQuote - 1);
}

inline float NPCProfileLoader::extractFloat(const std::string& json, const std::string& key, float defaultVal) {
    std::string searchKey = "\"" + key + "\"";
    size_t keyPos = json.find(searchKey);
    if (keyPos == std::string::npos) return defaultVal;

    size_t colonPos = json.find(':', keyPos);
    if (colonPos == std::string::npos) return defaultVal;

    size_t start = colonPos + 1;
    while (start < json.size() && (json[start] == ' ' || json[start] == '\n')) start++;

    size_t end = start;
    while (end < json.size() && (std::isdigit(json[end]) || json[end] == '.' || json[end] == '-')) end++;

    if (end == start) return defaultVal;

    try {
        return std::stof(json.substr(start, end - start));
    } catch (...) {
        return defaultVal;
    }
}

inline std::vector<std::string> NPCProfileLoader::extractStringArray(const std::string& json, const std::string& key) {
    std::vector<std::string> result;

    std::string searchKey = "\"" + key + "\"";
    size_t keyPos = json.find(searchKey);
    if (keyPos == std::string::npos) return result;

    size_t arrayStart = json.find('[', keyPos);
    if (arrayStart == std::string::npos) return result;

    size_t arrayEnd = json.find(']', arrayStart);
    if (arrayEnd == std::string::npos) return result;

    std::string arrayContent = json.substr(arrayStart + 1, arrayEnd - arrayStart - 1);

    size_t pos = 0;
    while (pos < arrayContent.size()) {
        size_t startQuote = arrayContent.find('"', pos);
        if (startQuote == std::string::npos) break;

        size_t endQuote = arrayContent.find('"', startQuote + 1);
        if (endQuote == std::string::npos) break;

        result.push_back(arrayContent.substr(startQuote + 1, endQuote - startQuote - 1));
        pos = endQuote + 1;
    }

    return result;
}

inline std::map<std::string, float> NPCProfileLoader::extractFloatMap(const std::string& json, const std::string& key) {
    std::map<std::string, float> result;

    std::string searchKey = "\"" + key + "\"";
    size_t keyPos = json.find(searchKey);
    if (keyPos == std::string::npos) return result;

    size_t objStart = json.find('{', keyPos);
    if (objStart == std::string::npos) return result;

    size_t objEnd = json.find('}', objStart);
    if (objEnd == std::string::npos) return result;

    std::string objContent = json.substr(objStart + 1, objEnd - objStart - 1);

    size_t pos = 0;
    while (pos < objContent.size()) {
        size_t keyStart = objContent.find('"', pos);
        if (keyStart == std::string::npos) break;

        size_t keyEnd = objContent.find('"', keyStart + 1);
        if (keyEnd == std::string::npos) break;

        std::string mapKey = objContent.substr(keyStart + 1, keyEnd - keyStart - 1);

        size_t colonPos = objContent.find(':', keyEnd);
        if (colonPos == std::string::npos) break;

        size_t valStart = colonPos + 1;
        while (valStart < objContent.size() && objContent[valStart] == ' ') valStart++;

        size_t valEnd = valStart;
        while (valEnd < objContent.size() && (std::isdigit(objContent[valEnd]) || objContent[valEnd] == '.' || objContent[valEnd] == '-')) valEnd++;

        try {
            result[mapKey] = std::stof(objContent.substr(valStart, valEnd - valStart));
        } catch (...) {}

        pos = valEnd;
    }

    return result;
}

// Static member initialization
inline bool NPCAIInitializer::initialized_ = false;
inline std::string NPCAIInitializer::dataDirectory_;

inline bool NPCAIInitializer::initialize(const std::string& dataDirectory, const std::string& profilesPath) {
    if (initialized_) return true;

    dataDirectory_ = dataDirectory;

    // Initialize the bridge
    ExultNPCBridge& bridge = ExultNPCBridge::getInstance();
    if (!bridge.initialize(dataDirectory + "/config.json")) {
        return false;
    }

    // Set up paths
    bridge.setAIMLPatternsPath(dataDirectory + "/aiml");
    bridge.setLLMModelPath(dataDirectory + "/models/tiny_llm.bin");

    // Load NPC profiles if provided
    if (!profilesPath.empty()) {
        auto profiles = NPCProfileLoader::loadFromFile(profilesPath);
        // Profiles will be registered when actors are available
    }

    initialized_ = true;
    return true;
}

inline void NPCAIInitializer::shutdown() {
    if (!initialized_) return;

    ExultNPCBridge::getInstance().shutdown();
    initialized_ = false;
}

inline bool NPCAIInitializer::isInitialized() {
    return initialized_;
}

inline void NPCAIInitializer::update(double deltaTime) {
    if (!initialized_) return;

    // The bridge handles individual NPC updates
    // This is called from Exult's main game loop
}

inline NPCAIInitializer::Stats NPCAIInitializer::getStats() {
    Stats stats = {0, 0, 0, 0.0};
    // TODO: Implement actual stats gathering
    return stats;
}

} // namespace Exult
} // namespace Ultima

#endif // NPC_PROFILE_LOADER_H
